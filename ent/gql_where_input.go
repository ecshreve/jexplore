// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"time"

	"github.com/ecshreve/jexplore/ent/game"
	"github.com/ecshreve/jexplore/ent/predicate"
	"github.com/ecshreve/jexplore/ent/season"
)

// GameWhereInput represents a where input for filtering Game queries.
type GameWhereInput struct {
	Predicates []predicate.Game  `json:"-"`
	Not        *GameWhereInput   `json:"not,omitempty"`
	Or         []*GameWhereInput `json:"or,omitempty"`
	And        []*GameWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "show" field predicates.
	Show      *int  `json:"show,omitempty"`
	ShowNEQ   *int  `json:"showNEQ,omitempty"`
	ShowIn    []int `json:"showIn,omitempty"`
	ShowNotIn []int `json:"showNotIn,omitempty"`
	ShowGT    *int  `json:"showGT,omitempty"`
	ShowGTE   *int  `json:"showGTE,omitempty"`
	ShowLT    *int  `json:"showLT,omitempty"`
	ShowLTE   *int  `json:"showLTE,omitempty"`

	// "airDate" field predicates.
	AirDate      *time.Time  `json:"airdate,omitempty"`
	AirDateNEQ   *time.Time  `json:"airdateNEQ,omitempty"`
	AirDateIn    []time.Time `json:"airdateIn,omitempty"`
	AirDateNotIn []time.Time `json:"airdateNotIn,omitempty"`
	AirDateGT    *time.Time  `json:"airdateGT,omitempty"`
	AirDateGTE   *time.Time  `json:"airdateGTE,omitempty"`
	AirDateLT    *time.Time  `json:"airdateLT,omitempty"`
	AirDateLTE   *time.Time  `json:"airdateLTE,omitempty"`

	// "tapeDate" field predicates.
	TapeDate      *time.Time  `json:"tapedate,omitempty"`
	TapeDateNEQ   *time.Time  `json:"tapedateNEQ,omitempty"`
	TapeDateIn    []time.Time `json:"tapedateIn,omitempty"`
	TapeDateNotIn []time.Time `json:"tapedateNotIn,omitempty"`
	TapeDateGT    *time.Time  `json:"tapedateGT,omitempty"`
	TapeDateGTE   *time.Time  `json:"tapedateGTE,omitempty"`
	TapeDateLT    *time.Time  `json:"tapedateLT,omitempty"`
	TapeDateLTE   *time.Time  `json:"tapedateLTE,omitempty"`

	// "season" edge predicates.
	HasSeason     *bool               `json:"hasSeason,omitempty"`
	HasSeasonWith []*SeasonWhereInput `json:"hasSeasonWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *GameWhereInput) AddPredicates(predicates ...predicate.Game) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the GameWhereInput filter on the GameQuery builder.
func (i *GameWhereInput) Filter(q *GameQuery) (*GameQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyGameWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyGameWhereInput is returned in case the GameWhereInput is empty.
var ErrEmptyGameWhereInput = errors.New("ent: empty predicate GameWhereInput")

// P returns a predicate for filtering games.
// An error is returned if the input is empty or invalid.
func (i *GameWhereInput) P() (predicate.Game, error) {
	var predicates []predicate.Game
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, game.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Game, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, game.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Game, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, game.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, game.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, game.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, game.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, game.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, game.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, game.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, game.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, game.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, game.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, game.IDContainsFold(*i.IDContainsFold))
	}
	if i.Show != nil {
		predicates = append(predicates, game.ShowEQ(*i.Show))
	}
	if i.ShowNEQ != nil {
		predicates = append(predicates, game.ShowNEQ(*i.ShowNEQ))
	}
	if len(i.ShowIn) > 0 {
		predicates = append(predicates, game.ShowIn(i.ShowIn...))
	}
	if len(i.ShowNotIn) > 0 {
		predicates = append(predicates, game.ShowNotIn(i.ShowNotIn...))
	}
	if i.ShowGT != nil {
		predicates = append(predicates, game.ShowGT(*i.ShowGT))
	}
	if i.ShowGTE != nil {
		predicates = append(predicates, game.ShowGTE(*i.ShowGTE))
	}
	if i.ShowLT != nil {
		predicates = append(predicates, game.ShowLT(*i.ShowLT))
	}
	if i.ShowLTE != nil {
		predicates = append(predicates, game.ShowLTE(*i.ShowLTE))
	}
	if i.AirDate != nil {
		predicates = append(predicates, game.AirDateEQ(*i.AirDate))
	}
	if i.AirDateNEQ != nil {
		predicates = append(predicates, game.AirDateNEQ(*i.AirDateNEQ))
	}
	if len(i.AirDateIn) > 0 {
		predicates = append(predicates, game.AirDateIn(i.AirDateIn...))
	}
	if len(i.AirDateNotIn) > 0 {
		predicates = append(predicates, game.AirDateNotIn(i.AirDateNotIn...))
	}
	if i.AirDateGT != nil {
		predicates = append(predicates, game.AirDateGT(*i.AirDateGT))
	}
	if i.AirDateGTE != nil {
		predicates = append(predicates, game.AirDateGTE(*i.AirDateGTE))
	}
	if i.AirDateLT != nil {
		predicates = append(predicates, game.AirDateLT(*i.AirDateLT))
	}
	if i.AirDateLTE != nil {
		predicates = append(predicates, game.AirDateLTE(*i.AirDateLTE))
	}
	if i.TapeDate != nil {
		predicates = append(predicates, game.TapeDateEQ(*i.TapeDate))
	}
	if i.TapeDateNEQ != nil {
		predicates = append(predicates, game.TapeDateNEQ(*i.TapeDateNEQ))
	}
	if len(i.TapeDateIn) > 0 {
		predicates = append(predicates, game.TapeDateIn(i.TapeDateIn...))
	}
	if len(i.TapeDateNotIn) > 0 {
		predicates = append(predicates, game.TapeDateNotIn(i.TapeDateNotIn...))
	}
	if i.TapeDateGT != nil {
		predicates = append(predicates, game.TapeDateGT(*i.TapeDateGT))
	}
	if i.TapeDateGTE != nil {
		predicates = append(predicates, game.TapeDateGTE(*i.TapeDateGTE))
	}
	if i.TapeDateLT != nil {
		predicates = append(predicates, game.TapeDateLT(*i.TapeDateLT))
	}
	if i.TapeDateLTE != nil {
		predicates = append(predicates, game.TapeDateLTE(*i.TapeDateLTE))
	}

	if i.HasSeason != nil {
		p := game.HasSeason()
		if !*i.HasSeason {
			p = game.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasSeasonWith) > 0 {
		with := make([]predicate.Season, 0, len(i.HasSeasonWith))
		for _, w := range i.HasSeasonWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasSeasonWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, game.HasSeasonWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyGameWhereInput
	case 1:
		return predicates[0], nil
	default:
		return game.And(predicates...), nil
	}
}

// SeasonWhereInput represents a where input for filtering Season queries.
type SeasonWhereInput struct {
	Predicates []predicate.Season  `json:"-"`
	Not        *SeasonWhereInput   `json:"not,omitempty"`
	Or         []*SeasonWhereInput `json:"or,omitempty"`
	And        []*SeasonWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "number" field predicates.
	Number      *int  `json:"number,omitempty"`
	NumberNEQ   *int  `json:"numberNEQ,omitempty"`
	NumberIn    []int `json:"numberIn,omitempty"`
	NumberNotIn []int `json:"numberNotIn,omitempty"`
	NumberGT    *int  `json:"numberGT,omitempty"`
	NumberGTE   *int  `json:"numberGTE,omitempty"`
	NumberLT    *int  `json:"numberLT,omitempty"`
	NumberLTE   *int  `json:"numberLTE,omitempty"`

	// "startDate" field predicates.
	StartDate      *time.Time  `json:"startdate,omitempty"`
	StartDateNEQ   *time.Time  `json:"startdateNEQ,omitempty"`
	StartDateIn    []time.Time `json:"startdateIn,omitempty"`
	StartDateNotIn []time.Time `json:"startdateNotIn,omitempty"`
	StartDateGT    *time.Time  `json:"startdateGT,omitempty"`
	StartDateGTE   *time.Time  `json:"startdateGTE,omitempty"`
	StartDateLT    *time.Time  `json:"startdateLT,omitempty"`
	StartDateLTE   *time.Time  `json:"startdateLTE,omitempty"`

	// "endDate" field predicates.
	EndDate      *time.Time  `json:"enddate,omitempty"`
	EndDateNEQ   *time.Time  `json:"enddateNEQ,omitempty"`
	EndDateIn    []time.Time `json:"enddateIn,omitempty"`
	EndDateNotIn []time.Time `json:"enddateNotIn,omitempty"`
	EndDateGT    *time.Time  `json:"enddateGT,omitempty"`
	EndDateGTE   *time.Time  `json:"enddateGTE,omitempty"`
	EndDateLT    *time.Time  `json:"enddateLT,omitempty"`
	EndDateLTE   *time.Time  `json:"enddateLTE,omitempty"`

	// "games" edge predicates.
	HasGames     *bool             `json:"hasGames,omitempty"`
	HasGamesWith []*GameWhereInput `json:"hasGamesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *SeasonWhereInput) AddPredicates(predicates ...predicate.Season) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the SeasonWhereInput filter on the SeasonQuery builder.
func (i *SeasonWhereInput) Filter(q *SeasonQuery) (*SeasonQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptySeasonWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptySeasonWhereInput is returned in case the SeasonWhereInput is empty.
var ErrEmptySeasonWhereInput = errors.New("ent: empty predicate SeasonWhereInput")

// P returns a predicate for filtering seasons.
// An error is returned if the input is empty or invalid.
func (i *SeasonWhereInput) P() (predicate.Season, error) {
	var predicates []predicate.Season
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, season.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Season, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, season.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Season, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, season.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, season.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, season.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, season.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, season.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, season.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, season.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, season.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, season.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, season.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, season.IDContainsFold(*i.IDContainsFold))
	}
	if i.Number != nil {
		predicates = append(predicates, season.NumberEQ(*i.Number))
	}
	if i.NumberNEQ != nil {
		predicates = append(predicates, season.NumberNEQ(*i.NumberNEQ))
	}
	if len(i.NumberIn) > 0 {
		predicates = append(predicates, season.NumberIn(i.NumberIn...))
	}
	if len(i.NumberNotIn) > 0 {
		predicates = append(predicates, season.NumberNotIn(i.NumberNotIn...))
	}
	if i.NumberGT != nil {
		predicates = append(predicates, season.NumberGT(*i.NumberGT))
	}
	if i.NumberGTE != nil {
		predicates = append(predicates, season.NumberGTE(*i.NumberGTE))
	}
	if i.NumberLT != nil {
		predicates = append(predicates, season.NumberLT(*i.NumberLT))
	}
	if i.NumberLTE != nil {
		predicates = append(predicates, season.NumberLTE(*i.NumberLTE))
	}
	if i.StartDate != nil {
		predicates = append(predicates, season.StartDateEQ(*i.StartDate))
	}
	if i.StartDateNEQ != nil {
		predicates = append(predicates, season.StartDateNEQ(*i.StartDateNEQ))
	}
	if len(i.StartDateIn) > 0 {
		predicates = append(predicates, season.StartDateIn(i.StartDateIn...))
	}
	if len(i.StartDateNotIn) > 0 {
		predicates = append(predicates, season.StartDateNotIn(i.StartDateNotIn...))
	}
	if i.StartDateGT != nil {
		predicates = append(predicates, season.StartDateGT(*i.StartDateGT))
	}
	if i.StartDateGTE != nil {
		predicates = append(predicates, season.StartDateGTE(*i.StartDateGTE))
	}
	if i.StartDateLT != nil {
		predicates = append(predicates, season.StartDateLT(*i.StartDateLT))
	}
	if i.StartDateLTE != nil {
		predicates = append(predicates, season.StartDateLTE(*i.StartDateLTE))
	}
	if i.EndDate != nil {
		predicates = append(predicates, season.EndDateEQ(*i.EndDate))
	}
	if i.EndDateNEQ != nil {
		predicates = append(predicates, season.EndDateNEQ(*i.EndDateNEQ))
	}
	if len(i.EndDateIn) > 0 {
		predicates = append(predicates, season.EndDateIn(i.EndDateIn...))
	}
	if len(i.EndDateNotIn) > 0 {
		predicates = append(predicates, season.EndDateNotIn(i.EndDateNotIn...))
	}
	if i.EndDateGT != nil {
		predicates = append(predicates, season.EndDateGT(*i.EndDateGT))
	}
	if i.EndDateGTE != nil {
		predicates = append(predicates, season.EndDateGTE(*i.EndDateGTE))
	}
	if i.EndDateLT != nil {
		predicates = append(predicates, season.EndDateLT(*i.EndDateLT))
	}
	if i.EndDateLTE != nil {
		predicates = append(predicates, season.EndDateLTE(*i.EndDateLTE))
	}

	if i.HasGames != nil {
		p := season.HasGames()
		if !*i.HasGames {
			p = season.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasGamesWith) > 0 {
		with := make([]predicate.Game, 0, len(i.HasGamesWith))
		for _, w := range i.HasGamesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasGamesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, season.HasGamesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptySeasonWhereInput
	case 1:
		return predicates[0], nil
	default:
		return season.And(predicates...), nil
	}
}
